## Лекция 2

##### Что происходит в получившейся реализации, если в программе есть рекурсивный тип?
В текущей реализации используется регулярная унификация на основе union-find солвера (`src/tip/solvers/UnionFindSolver.scala`). Она разрешает использовать рекурсивные термы, в отличие от линейного алгоритма унификации. В итоге программа будет типизированна с использованием μ-нотации. Пример (`examples/rectype.tip`):

Исходная программа:

```
main() {
    var p;
    p = alloc null;
    *p=p;
    return 0;
}
```

Выведенные типы:

```
Inferred types:
  ⟦0[5:12]⟧ = int
  ⟦null[3:15]⟧ = ⭡x7
  ⟦main(){...}:1:1⟧ = () -> x5
  ⟦p[2:9]⟧ = ⭡μx6.⭡x6
  ⟦alloc null[3:9]⟧ = ⭡μx6.⭡x6
```

##### Что будет, если в нашу систему ввести тип Bool?
Изменившиеся правила:
1. E_1 == E_2 <=> [[E_1]] == [[E_2]] /\ [[E_1 == E_2]] == Bool
2. if (E) ... <=> [[E]] == Bool
3. while (E) ... <=> [[E]] == Bool

Precision не изменится, т.к. мы по-прежнему будем пускать только корректные программы.
Recall ухудшится, т.к. перестанут проходить корректные семантически программы (число slack'ов увеличится). Пример: 

```
int x = 1;
if (x) ...
```

не пропустит тайпчекер, хотя мог бы (точно знаем, что должны войти в `if`).

##### Что будет, если в нашу систему ввести тип Array?
Вводим Array с типовым параметром alpha (обозначим как Array<alpha>)
Изменившиеся правила:
1. X[E_1] op E_2 <=> [[ X[E_1] ]] == [[E]] /\ [[E_1]] == int /\ [[X]] == Array<[[E_1]]>
2. X = {X_1, X_2, ..., X_N} <=> forall i, j: [[X_i]] == [[X_j]] /\ [[X]] Array<[[X_i]]>
3. A[E] <=> [[E]] == int /\ [[A]] == Array<alpha> /\ [[ A[E] ]] == alpha
4. {} <=> [[ {} ]] == Array<alpha>

Типизированная программа:

```
main() {
    var x, y, z, t;
    x = {2, 4, 8, 16, 32, 64};    // [[x]] == Array<Int>
    y = x[x[3]];                  // [[y]] == Int
    z = {{}, x};                  // [[z]] == Array<Array<Int>>
    t = z[1];                     // [[t]] == Array<Int>
    t[2] = y;
}
```